
#include "../include/support.h"
#include "../include/cdata.h"
#include <stdlib.h>
#define ERRO -1
#define SUCESSO 0



PFILA2 aptos;
PFILA2 bloqueados;
PFILA2 executando;
PFILA2 esperando;
PFILA2 terminado;
int numT = 1;
int filascriadas = 0;
ucontext_t escalonador;
TCB_t thread_main;

void escalonadorupdate(){
   TCB_t* tcb = GetAtIteratorFila2(executando);
    if(tcb != NULL){
       tcb->state = PROCST_TERMINO;
       AppendFila2(terminado, tcb);
       DeleteAtIteratorFila2(executando);
    }

}

int cidentify (char *name, int size){
  return ERRO;
}

/*
  TCB_t* dispatcher(){
 
  }
  void escalonador(){
  	swapcontext();
  }
*/
char ss_sp_escalonador[SIGSTKSZ];

void init_escalonador() {
  getcontext(&escalonador);
  escalonador.uc_link = &(thread_main.context);
  escalonador.uc_stack.ss_sp = ss_sp_escalonador;
  escalonador.uc_stack.ss_size = SIGSTKSZ;
  makecontext(&escalonador, (void (*)(void))escalonadorupdate,0);
}

void CriaFilas(){
  printf("Criando fila Aptos\n");
  CreateFila2(&aptos);
  printf("Criando fila bloqueados\n");
  CreateFila2(&bloqueados);
  printf("Criando fila executando\n");
  CreateFila2(&executando);
  printf("Criando fila esperando\n");
  CreateFila2(&esperando);
  printf("Criando fila terminado\n");
  CreateFila2(&terminado);
  filascriadas = 1;
}

void Create_Main_Thread()
{
    thread_main.tid = 0;
    thread_main.state = PROCST_EXEC;
    getcontext(&thread_main.context);
}

void InicializaVariavies()
{
    printf("Criando escalonador\n");
    init_escalonador();
    printf("Criando Main Thread\n");
    Create_Main_Thread();
    printf("Criando Filas\n");
    CriaFilas();
}


TCB_t* check_tid_apto(int tid){
    TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
    if(!FirstFila2(aptos)) {

    do{
      tcb = GetAtIteratorFila2(aptos);
      if(tcb->tid == tid) return tcb;
    }while( !(NextFila2(aptos)) );
}
    return NULL;
}

TCB_t* check_tid_esperando(int tid){
    TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
    if(!FirstFila2(esperando)) {

    do{
      tcb = GetAtIteratorFila2(esperando);
      if(tcb->tid == tid) return tcb;
    }while( !(NextFila2(esperando)) );
}
    return NULL;
}

TCB_t* check_tid_bloqueados(int tid){
    TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
    if(!FirstFila2(bloqueados)) {

    do{
      tcb = GetAtIteratorFila2(bloqueados);
      if(tcb->tid == tid) return tcb;
    }while( !(NextFila2(bloqueados)) );
}
    return NULL;
}


void finalizer(){
    // se ha alguma thread esperando esta que termina, libera a thread para aptos
    //if(executando->bloqueando){
	//acha ponteiro na fila de bloqueados
	//deleta ponteiro na fila de bloqueados
	//coloca thread em aptos
        ///TCB_t* tcb = executando->bloqueando;
	///tcb->PROCST_APTO;
	///tcb
    //}
}
//int iniciaThreads(){
//  CreateFila2(aptos);
//  CreateFila2(bloqueados);
//  CreateFila2(executando);
//  CreateFila2(esperando);

//  TCB_t* tcbmain = (TCB_t*) malloc(sizeof(TCB_t));
//  tcbmain->tid = numT++;
//  tcbmaind->state = PROCST_EXEC;
//  tcbmain->context.uc_link = NULL;
//  tcbmain->context.uc_stack.ss_sp = malloc(SIGSTKSZ);
//  tcbmain->context.uc_stack.size = SIGSTKSZ;

//  AppendFila2(executando, tcbmain);
//  getcontext(&(tcbmain->context));
//  TCB_t
//  return SUCESSO;
//}

int ccreate (void* (*start)(void*), void *arg, int prio) {
  printf("Iniciando teste ccreate...\n");
  // Crias as listas e a thread de start
  if(!filascriadas){
	InicializaVariavies();
	}
  // Cria uma nova thread
  TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
  tcb->tid = numT++;
  tcb->state = PROCST_APTO;
  getcontext(&(tcb->context));
  tcb->context.uc_link = &escalonador;
  char stack_tcb[SIGSTKSZ];
  tcb->context.uc_stack.ss_sp = stack_tcb;
  tcb->context.uc_stack.ss_size = SIGSTKSZ;
  tcb->prio = prio;
  makecontext(&(tcb->context), (void(*)(void)) start, 1, arg);
  AppendFila2(&aptos, tcb);
  return tcb->tid;
}

int cyield(void){
  TCB_t *thread = GetAtIteratorFila2(executando);
  thread->state = PROCST_APTO;
  int erro = 0;
  if(AppendFila2(aptos, thread)!=0){erro =  1;}
  if(DeleteAtIteratorFila2(executando)!=0){erro = 1;}

  if(erro == 1){return ERRO;}
  else
     {
  swapcontext(&thread->context,&escalonador);
  //escalonadorupdate();
  return SUCESSO;
     }
}

int cjoin(int tid){
  
  return ERRO;
}

//csem_t semaforos;
int csem_init(csem_t *sem, int count){
    sem = (csem_t*) malloc (sizeof(csem_t));
    sem->count = 1;
    CreateFila2(sem->fila);
    if(sem->fila) return SUCESSO;
    return ERRO; //caso fila nao tenha sido alocada corretamente
}
//int cwait(csem_t *sem){
//  return ERRO;
//}
int csignal(csem_t *sem){
	if(sem->fila == NULL) return ERRO;
	if(FirstFila2(sem->fila) == 0){ // fila nao vazia
		TCB_t *thread = GetAtIteratorFila2(sem->fila);
		DeleteAtIteratorFila2(sem->fila);
		AppendFila2(aptos, thread);
		thread->state = PROCST_APTO;
	}
	else{ //fila vazia, apenas incrementa o contador de volta para 1
		sem->count++;
	}
	return SUCESSO;
}
