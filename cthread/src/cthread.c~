
#include "../include/support.h"
#include "../include/cdata.h"
#include <stdlib.h>
#define ERRO -1
#define SUCESSO 0



PFILA2 aptos;
PFILA2 bloqueados;
PFILA2 esperando;
PFILA2 terminado;
PFILA2 executando;
TCB_t* thread_executando;

int numT = 1;
int filascriadas = 0;
ucontext_t escalonador;
TCB_t thread_main;

void escalonadorupdate(){
  printf("escalonador iniciando os trabalhos\n");
  if(thread_executando!=NULL){
	printf("escalonador liberando os recursos\n");
        thread_executando->state = PROCST_TERMINO;
	AppendFila2(&terminado, thread_executando);
 	thread_executando = NULL;   
        }
  if(LastFila2(&aptos)!=0){
	printf("A fila de aptos estÃ¡ vazia\n");
	return;
	}
  thread_executando = GetAtIteratorFila2(&aptos);
 // if(thread_executando = NULL){
//	thread_executando = &thread_main;
  //}
  thread_executando->state = PROCST_EXEC;
  printf("Passando os recursos para a thread %d \n",thread_executando->tid);
  setcontext(&thread_executando->context);
}

int cidentify (char *name, int size){
  printf("Alberto Pena Neto - 217444\nIago Martins - 240499\nMateus Heck - 206740");
  return SUCESSO;
}

/*
  TCB_t* dispatcher(){
 
  }
  void escalonador(){
  	swapcontext();
  }
*/
char ss_sp_escalonador[SIGSTKSZ];

void init_escalonador() {
  getcontext(&escalonador);
  escalonador.uc_link = &(thread_main.context);
  escalonador.uc_stack.ss_sp = ss_sp_escalonador;
  escalonador.uc_stack.ss_size = SIGSTKSZ;
  makecontext(&escalonador, (void (*)(void))escalonadorupdate,0);
}

void CriaFilas(){
  printf("Criando fila Aptos\n");
  CreateFila2(&aptos);
  printf("Criando fila bloqueados\n");
  CreateFila2(&bloqueados);
  printf("Criando fila executando\n");
  CreateFila2(&executando);
  printf("Criando fila esperando\n");
  CreateFila2(&esperando);
  printf("Criando fila terminado\n");
  CreateFila2(&terminado);
  filascriadas = 1;
}

void Create_Main_Thread()
{
    thread_main.tid = 0;
    thread_main.state = PROCST_EXEC;
    getcontext(&thread_main.context);
    thread_executando = &thread_main;
}

void InicializaVariavies()
{
    printf("Criando Filas\n");
    CriaFilas();
    printf("Criando escalonador\n");
    init_escalonador();
    printf("Criando Main Thread\n");
    Create_Main_Thread();   
}


TCB_t* check_tid_apto(int tid){
    TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
    if(!FirstFila2(aptos)) {

    do{
      tcb = GetAtIteratorFila2(aptos);
      if(tcb->tid == tid) return tcb;
    }while( !(NextFila2(aptos)) );
}
    return NULL;
}

TCB_t* check_tid_esperando(int tid){
    TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
    if(!FirstFila2(esperando)) {

    do{
      tcb = GetAtIteratorFila2(esperando);
      if(tcb->tid == tid) return tcb;
    }while( !(NextFila2(esperando)) );
}
    return NULL;
}

TCB_t* check_tid_bloqueados(int tid){
    TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
    if(!FirstFila2(bloqueados)) {

    do{
      tcb = GetAtIteratorFila2(bloqueados);
      if(tcb->tid == tid) return tcb;
    }while( !(NextFila2(bloqueados)) );
}
    return NULL;
}


void finalizer(){
    // se ha alguma thread esperando esta que termina, libera a thread para aptos
    //if(executando->bloqueando){
	//acha ponteiro na fila de bloqueados
	//deleta ponteiro na fila de bloqueados
	//coloca thread em aptos
        ///TCB_t* tcb = executando->bloqueando;
	///tcb->PROCST_APTO;
	///tcb
    //}
}
//int iniciaThreads(){
//  CreateFila2(aptos);
//  CreateFila2(bloqueados);
//  CreateFila2(executando);
//  CreateFila2(esperando);

//  TCB_t* tcbmain = (TCB_t*) malloc(sizeof(TCB_t));
//  tcbmain->tid = numT++;
//  tcbmaind->state = PROCST_EXEC;
//  tcbmain->context.uc_link = NULL;
//  tcbmain->context.uc_stack.ss_sp = malloc(SIGSTKSZ);
//  tcbmain->context.uc_stack.size = SIGSTKSZ;

//  AppendFila2(executando, tcbmain);
//  getcontext(&(tcbmain->context));
//  TCB_t
//  return SUCESSO;
//}

int ccreate (void* (*start)(void*), void *arg, int prio) {
  printf("Iniciando teste ccreate...\n");
  // Crias as listas e a thread de start
  if(!filascriadas){
	InicializaVariavies();
	}
  // Cria uma nova thread
  TCB_t* tcb = (TCB_t*) malloc(sizeof(TCB_t));
  tcb->tid = numT++;
  tcb->state = PROCST_APTO;
  getcontext(&(tcb->context));
  tcb->context.uc_link = &escalonador;
  char stack_tcb[SIGSTKSZ];
  tcb->context.uc_stack.ss_sp = stack_tcb;
  tcb->context.uc_stack.ss_size = SIGSTKSZ;
  tcb->prio = prio;
  makecontext(&(tcb->context), (void(*)(void)) start, 1, arg);
  AppendFila2(&aptos, tcb);
  printf("Thread criada, tid %d \n",tcb->tid);
  return tcb->tid;
}

int cyield(void){
  printf("Iniciando yield \n");
  TCB_t *thread = thread_executando;
  thread->state = PROCST_APTO;
  thread_executando=NULL;
  printf("Thread %d liberou a cpu\n",thread->tid);  
  swapcontext(&thread->context,&escalonador);
  return SUCESSO;
}


int cjoin(int tid){
  
 
  return ERRO;
}

//csem_t semaforos;
int csem_init(csem_t *sem, int count){
    sem = (csem_t*) malloc (sizeof(csem_t));
    sem->count = 1;
    CreateFila2(sem->fila);
    if(sem->fila) return SUCESSO;
    return ERRO; //caso fila nao tenha sido alocada corretamente
}

//int cwait(csem_t *sem){
//  return ERRO;
//}
int csignal(csem_t *sem){
	if(sem->fila == NULL) return ERRO;
	if(FirstFila2(sem->fila) == 0){ // fila nao vazia
		TCB_t *thread = GetAtIteratorFila2(sem->fila);
		DeleteAtIteratorFila2(sem->fila);
		AppendFila2(aptos, thread);
		thread->state = PROCST_APTO;
	}
	else{ //fila vazia, apenas incrementa o contador de volta para 1
		sem->count++;
	}
	return SUCESSO;
}
